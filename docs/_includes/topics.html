<h2>Topics</h2>

<h4>Lambda Calculus</h4>

<ol>
<li>introducing transition system rules for a while programming language </li>
<li>expanding to procedures and recursion (eager evaluation)</li>
<li>syntax of LC, bound and free variables, currying, substitution</li>
<li>beta reduction, lambda calculus rules</li>
<li>church numerals, pairs, fixed points, while</li>
<li>equivalence, eta reduction, normal forms</li>
<li>Church-Rosser property</li>
</ol>

<h4>Logic</h4>

<ol>
<li>introduction to propositional natural deduction</li>
<li>truth tables, normal forms, satisfiability</li>
<li>functions, relations, terms, satisfaction</li>
<li>quantifiers and natural deduction inference</li>
<li>states, assertions, invariants</li>
<li>theories</li>
<li>predicate transformers</li>
<li>Hoare logic</li>
</ol>

<h4>Set theory</h4>

<ol>
<li>Zermelo-Fraenkel: ideas and axioms</li>
<li>specification and first-order logic</li>
<li>unions, products, equinumerousness</li>
<li>function space, powerset, diagonal argument</li>
<li>relations, reflexive transitive closure</li>
<li>equivalences, partitions</li>
<li>the axiom of choice and transfinite induction</li>
</ol>

<h4>Type theory</h4>

<ol>
    <li>typed languages</li>
    <li>function types: simply typed lambda calculus</li>
    <li>product types and Currying</li>
    <li>natural numbers, recursive definitions including function valued (e.g. Ackermann functions)</li>
    <li>parametric types (poymorphism)</li>
    <li>inductive types</li>
    <li>dependent types</li>
    <li>propositions as types; integrated </li>
</ol>
